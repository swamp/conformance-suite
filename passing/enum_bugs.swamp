/*
 * Copyright (c) Peter Bjorklund. All rights reserved. https://github.com/swamp/conformance-suite
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */

 /// # Problem
 ///
 /// When initializing enum variants with collection payloads (like Vec), the collection's capacity
 /// wasn't being properly set.
type UnitID = Int

enum EnumCapacityPayload {
    Message,
    RefreshUnits Vec<UnitID;30>,
    StructPayload { units: Vec<UnitID;40> }
}


#[test]
fn unit_payload() {
    x := EnumCapacityPayload::Message
    assert(x == EnumCapacityPayload::Message, "should be equal")
}

#[test]
fn complex_payload_empty() {
    x := EnumCapacityPayload::RefreshUnits([])

    match x {
        RefreshUnits units -> {
            print('units: {units}')
        }
        _ -> {}
    }
}

#[test]
fn complex_payload_from_other_empty_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    x := EnumCapacityPayload::RefreshUnits(unit_id_list)

    match x {
        RefreshUnits units -> {
            print('units: {units}')
        }
        _ -> {}
    }
}


/// Showing the problems with capacity not being set correctly
/// recursively in the Variant Literal `RefreshUnits`:
///
/// ```asm
///  ; x := EnumCapacityPayload::RefreshUnits(unit_id_list)
///   v73: &EnumCapacityPayload = &frame1
///   clr v73, #172
///  st.h [v73 + 4], 30
///  st.w [v73 + 8], -1073626914
///  st.h [v73 + 4], 40 // OVERWRITE
///  st.w [v73 + 8], -1073626914
///  st.b [v73], 1
/// ```asm
#[test]
fn complex_payload_from_other_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    for i in 0..23 {
        unit_id_list.push(i)
    }

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 23, 'len wrong {unit_id_list.len()}')

    x := EnumCapacityPayload::RefreshUnits(unit_id_list)
    match x {
        RefreshUnits units -> {
            assert(units.capacity() == 30, 'struct payload capacity wrong {units.capacity()}')
            assert(units.len() == 23, 'struct payload len wrong {units.len()}')
        }
        _ -> {
            panic("wrong variant matched")
        }
    }
}

#[test]
fn struct_payload_with_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    for i in 0..15 {
        unit_id_list.push(i)
    }

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 15, 'len wrong {unit_id_list.len()}')

    x := EnumCapacityPayload::StructPayload { units: unit_id_list }

    match x {
        StructPayload { units } -> {
            assert(units.capacity() == 40, 'struct payload capacity wrong {units.capacity()}')
            assert(units.len() == 15, 'struct payload len wrong {units.len()}')
        }
        _ -> {
            panic("wrong variant matched")
        }
    }
}

enum Wind {
	West,
	East,
}


impl Wind {
	fn opposite(self) -> Wind {
		match self {
			West -> East,
			East -> West,
		}
	}
}

fn opposite(wind: Wind) -> Wind {
	match wind {
		West -> East,
		East -> West,
	}
}

struct SomeUnit {
	wind: Wind,
}

fn function_that_uses_enum(wind: Wind) {
	print('wind: {wind}')
	assert(wind == East, 'wrong wind {wind}')
}

/// Found by @catnipped
/// Must look at the assembly to see that a register
/// is allocated for the temp value in the parameter (store.wind.opposite())-return
/// But no memory is allocated for it! So it depends on what that temp register was used for previously
#[test]
fn temp_memory_for_enum_function_return() {
	store := SomeUnit {
		wind: Wind::West,
	}
	// no memory is allocated for the return register (r0)
	// so it overwrites memory depending on the value in the temp register
	function_that_uses_enum(store.wind.opposite())
	function_that_uses_enum(opposite(store.wind))
}
