/*
 * Copyright (c) Peter Bjorklund. All rights reserved. https://github.com/swamp/conformance-suite
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */

type UnitId = Int

enum Alliance {
	West,
	East,
}

impl Alliance {
	fn opposite(self) -> Alliance {
		match self {
			West -> East,
			East -> West,
		}
	}
}

enum ActionType {
	Blank, // ZII-rule (Zero is initialization)
	Move,
	Attack,
}

struct Action {
	type: ActionType,
}

enum Keyword {
	EnterAction(Action),
	Confused,
}

struct Unit {
	id: UnitId,
	alliance: Alliance,
	keywords: Vec<Keyword;100>,
}

struct Game {
	unit_turn_order: Vec<UnitId; 100>,
	units_spawned: [UnitId: Unit; 100],
}


// Intentionally avoid using transformer to find keyword
fn find_keyword(keywords: Vec<Keyword>, target_keyword: Keyword) -> Bool {
	mut found = false
	for k in keywords{
		if k.discriminant() == target_keyword.discriminant() { found = true }
	}
	found
}


/// found by @catnipped
#[test]
fn filter_without_call() {
	mut possible_targets: Vec<UnitId; 15> = []

	game := Game {
		unit_turn_order: [2, 1],
		units_spawned: [
			1: Unit { id: 1, alliance: West, .. },
			2: Unit { id: 2, alliance: East, .. },
		]
	}

	this_unit := game.units_spawned[1]

	possible_targets = game.unit_turn_order.filter(|id| id != this_unit.id && game.units_spawned[id].alliance == this_unit.alliance.opposite())

	assert(possible_targets.len() == 1, 'expected one in the opposite alliance {possible_targets.len()}')
	assert(possible_targets[0] == 2, 'the target should be 2, but got {possible_targets}') // FIXME:Missing to_string implementation Vec<Int, 15>
}


/// Found by @catnipped
/// when target vector is the same as the source vector for filter
/// temp_possible_targets = possible_targets.filter()
/// In the future there should be a `.filter_mut()` which mutates the vector directly
#[test]
fn filter_with_call() {
	mut possible_targets: Vec<UnitId; 15> = []

	// Setup the game with two opponent units, one is Confused
	game := Game {
		unit_turn_order: [2, 1, 3],
		units_spawned: [
			1: Unit { id: 1, alliance: West, .. },
			2: Unit { id: 2, alliance: East, keywords: [Confused] },
			3: Unit { id: 3, alliance: East, .. },
		]
	}

	this_unit := game.units_spawned[1]

	// First we only keep the units of opposite alliance
	possible_targets = game.unit_turn_order.filter(|id| id != this_unit.id && game.units_spawned[id].alliance == this_unit.alliance.opposite())
	assert(possible_targets.len() == 2, 'expected two in the opposite alliance {possible_targets.len()}')

	// Then we want want to keep those that are not confused
	mut temp_possible_targets: Vec<UnitId; 15> = []
	temp_possible_targets = possible_targets.filter(|id| !find_keyword(game.units_spawned[id].keywords, Keyword::Confused) )
	assert(temp_possible_targets.len() == 1, 'expected one in the opposite alliance {temp_possible_targets.len()} to not be confused')
	assert(temp_possible_targets[0] == 3, 'the target should be 3, since id 2 is confused, but got {temp_possible_targets}')
}

#[test]
fn find_in_bool_condition() {
	mut possible_targets: Vec<UnitId; 15> = []

	// Setup the game with two opponent units, one is Confused
	game := Game {
		unit_turn_order: [2, 1, 3],
		units_spawned: [
			1: Unit { id: 1, alliance: West, .. },
			2: Unit { id: 2, alliance: East, keywords: [Confused] },
			3: Unit { id: 3, alliance: East, .. },
		]
	}

    keyword_to_find := Keyword::Confused
    instance_id : UnitId = 2
    if game.units_spawned[instance_id].keywords.find(|k| k.discriminant() == keyword_to_find.discriminant()) {
        print('worked!')
    } else {
        panic("was not correct")
    }


    keyword_to_not_find := Keyword::EnterAction({ type: Blank })

    if game.units_spawned[instance_id].keywords.find(|k| k.discriminant() == keyword_to_not_find.discriminant()) {
        panic("you should NOT find it")
    } else {
       print('worked - could not find it')
    }
}