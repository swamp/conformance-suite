/*
 * Copyright (c) Peter Bjorklund. All rights reserved. https://github.com/swamp/conformance-suite
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */

struct Vec2 {
    x: Int,
    y: Int,
}

struct Vec3 {
    x: Int,
    y: Int,
    z: Int,
}

struct Transform {
    position: Vec2,
    rotation: Float,
    scale: Vec2,
}

struct LargeData {
    values: [Int; 16],
    checksum: Int,
}

fn create_vec2(x: Int, y: Int) -> Vec2 {
    { x: x, y: y }
}

fn create_vec3(x: Int, y: Int, z: Int) -> Vec3 {
     { x: x, y: y, z: z }
}

fn create_vec2_out(out result: Vec2, x: Int, y: Int) {
    result.x = x
    result.y = y
}

fn create_vec3_out(out result: Vec3, x: Int, y: Int, z: Int) {
    result.x = x
    result.y = y
    result.z = z
}

fn add_vec2_out(out result: Vec2, a: Vec2, b: Vec2) {
    result.x = a.x + b.x
    result.y = a.y + b.y
}

fn scale_vec2_out(out result: Vec2, v: Vec2, scale: Int) {
    result.x = v.x * scale
    result.y = v.y * scale
}

fn make_transform_out(out result: Transform, x: Int, y: Int, rot: Float, sx: Int, sy: Int) {
    result.position.x = x
    result.position.y = y
    result.rotation = rot
    result.scale.x = sx
    result.scale.y = sy
}


#[test]
fn implicit_sret_basic() {
    v := create_vec2(10, 20)
    assert(v.x == 10, "sret x should be 10")
    assert(v.y == 20, "sret y should be 20")
}

#[test]
fn implicit_sret_nested() {
    v := create_vec3(1, 2, 3)
    assert(v.x == 1, "nested sret x wrong")
    assert(v.y == 2, "nested sret y wrong")
    assert(v.z == 3, "nested sret z wrong")
}

#[test]
fn explicit_out_param_basic() {
    v := create_vec2_out(5, 15)
    assert(v.x == 5, "out param x should be 5")
    assert(v.y == 15, "out param y should be 15")
}

#[test]
fn explicit_out_param_computation() {
    a := Vec2 { x: 10, y: 20 }
    b := Vec2 { x: 5, y: 10 }
    result := add_vec2_out(a, b)
    assert(result.x == 15, "addition x wrong")
    assert(result.y == 30, "addition y wrong")
}

#[test]
fn explicit_out_param_scaling() {
    v := Vec2 { x: 3, y: 4 }
    scaled := scale_vec2_out(v, 10)
    assert(scaled.x == 30, "scaled x wrong")
    assert(scaled.y == 40, "scaled y wrong")
}

#[test]
fn explicit_out_nested_struct() {
    t := make_transform_out(100, 200, 3.14, 2, 2)
    assert(t.position.x == 100, "transform position.x wrong")
    assert(t.position.y == 200, "transform position.y wrong")
    assert(t.rotation == 3.14, "transform rotation wrong")
    assert(t.scale.x == 2, "transform scale.x wrong")
    assert(t.scale.y == 2, "transform scale.y wrong")
}

impl Vec2 {
    fn scale(self, factor: Int) -> Vec2 {
        Vec2 { x: self.x * factor, y: self.y * factor }
    }

    fn scale_out(out result: Vec2, self, factor: Int) {
        result.x = self.x * factor
        result.y = self.y * factor
    }

    fn add(self, other: Vec2) -> Vec2 {
        Vec2 { x: self.x + other.x, y: self.y + other.y }
    }
}

#[test]
fn member_function_implicit_sret() {
    v := Vec2 { x: 5, y: 10 }
    scaled := v.scale(3)
    assert(scaled.x == 15, "member sret scale x wrong")
    assert(scaled.y == 30, "member sret scale y wrong")
}

#[test]
fn member_function_explicit_out() {
    v := Vec2 { x: 7, y: 14 }
    result := v.scale_out(2)
    assert(result.x == 14, 'member out x wrong {result}')
    assert(result.y == 28, "member out y wrong")
}

#[test]
fn chained_sret_calls() {
    v1 := create_vec2(1, 2)
    v2 := create_vec2(3, 4)
    sum := v1.add(v2)
    assert(sum.x == 4, "chained x wrong")
    assert(sum.y == 6, "chained y wrong")
}

fn create_large_data(value: Int) -> LargeData {
    mut data = LargeData {
        values: [],
        checksum: 0,
    }
    mut sum = 0
    for i in 0..16 {
        data.values[i] = value + i
        sum += data.values[i]
    }
    data.checksum = sum
    data
}

#[test]
fn large_struct_sret() {
    data := create_large_data(100)
    assert(data.values[0] == 100, "large struct first value wrong")
    assert(data.values[15] == 115, "large struct last value wrong")
    assert(data.checksum > 0, "checksum should be calculated")
}

#[test]
fn builtin_sret_normalize() {
    // normalize() on tuple returns normalized tuple via SRET
    norm_x, norm_y = (10.0, 20.0).normalize()
    // Verify it's normalized (magnitude should be ~1.0)
    mag_squared := (norm_x * norm_x) + (norm_y * norm_y)
    // Should be close to 1.0 (allowing for FP precision)
    assert(mag_squared > 0.99 && mag_squared < 1.01, "normalize sret failed")
}



fn conditional_out(out result: Vec2, use_x: Bool, value: Int) {
    if use_x {
        result.x = value
        result.y = 0
    } else {
        result.x = 0
        result.y = value
    }
}

#[test]
fn out_param_conditional() {
    v1 := conditional_out(true, 42)
    assert(v1.x == 42, "conditional x wrong")
    assert(v1.y == 0, "conditional y should be 0")

    v2 := conditional_out(false, 99)
    assert(v2.x == 0, "conditional x should be 0")
    assert(v2.y == 99, "conditional y wrong")
}

fn create_one_vec_out(out v1: Vec2, base: Int) {
    v1.x = base
    v1.y = base + 1
}

#[test]
fn multiple_out_params() {
    b := create_one_vec_out(10)
    assert(b.x == 10 && b.y == 11, 'out param wrong {b}')
}
